<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>btdt - User Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">btdt - User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jgosmann/btdt" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="btdt-been-there-done-that"><a class="header" href="#btdt-been-there-done-that">btdt: "been there, done that"</a></h1>
<p><code>btdt</code> is a tool for flexible caching files in CI pipelines.
By being a simple CLI program, it is agnostic to the CI platform and can be integrated into various pipelines.</p>
<p><strong>This tool is still under active development and not feature complete yet.</strong>
See below for details.</p>
<h2 id="example-caching-node_modules"><a class="header" href="#example-caching-node_modules">Example: caching <code>node_modules</code></a></h2>
<pre><code class="language-sh">CACHE_KEY=node-modules-$(btdt hash package-lock.json)
btdt restore --cache path/to/cache --keys $CACHE_KEY node_modules
if [ $? -ne 0 ]; then
    npm ci
    btdt store --cache path/to/cache --keys $CACHE_KEY node_modules
fi
</code></pre>
<p>Examples for specific CI platforms can be found in the documentation (see below).</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>The main user guide and documentation is located at <a href="https://jgosmann.github.io/btdt">https://jgosmann.github.io/btdt</a>.
The API documentation is found on <a href="https://docs.rs/btdt/latest/btdt/">docs.rs</a></p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>I was annoyed that there isn't a good (self-hosted) caching solution for Jenkins and Tekton, similar to the
cache for GitHub Actions.
Also, it seemed that it shouldn't be that hard to implement a caching solution.
So I put my money where my mouth is.
In particular, I didn't see any reason why caching should be tied to a specific CI platform by implementing it as a
plugin for that platform.
To me, it seems, that this problem is solvable with a CLI tool that can be integrated into any pipeline.</p>
<p>Regarding Jenkins, I know of two caching plugins and I have my quarrels with both of them:</p>
<ul>
<li><a href="https://plugins.jenkins.io/jobcacher/">Job Cacher</a> will delete the complete cache once it reaches the maximum size.
This is inefficient and I prefer to delete least recently used caches until the limit is met. The plugin also does
not share the cache between different build jobs which severely limits its usefulness in certain scenarios. We also
had some other constraints that made it impossible to use this plugin, but a CLI tool could have been integrated.</li>
<li><a href="https://github.com/j3t/jenkins-pipeline-cache-plugin">jenkins-pipeline-cache-plugin</a> requires S3 API compatible
storage, which excludes some other use cases. It also doesn't seem to provide a way to limit the cache size.</li>
</ul>
<h2 id="state-of-development"><a class="header" href="#state-of-development">State of development</a></h2>
<p>A basic version of <code>btdt</code> that can be used in some scenarios is working.
I still intend to implement the following features:</p>
<ul>
<li>A server for storing caches remotely.</li>
<li>Compression of the cache (to reduce the amount of data transferred).</li>
<li>Hashing multiple files in a stable way for the cache key.</li>
<li>A templating system for cache keys, such that <code>btdt hash</code> doesn't need to be called,
but a cache key in the form of <code>cache-key-${hashFiles('**/package-lock.json')}</code> can be used directly.</li>
<li>Potentially, configuration via environment variables and/or configuration files.</li>
<li>Potentially, using S3 compatible APIs as storage backend.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>There are multiple ways to install <code>btdt</code>. Choose the method from below that best fits your needs.</p>
<div class="warning">
<p>Currently, only Unix (Linux, macOS) systems are supported.</p>
</div>
<h2 id="pre-compiled-binaries"><a class="header" href="#pre-compiled-binaries">Pre-compiled binaries</a></h2>
<p>You can download pre-compiled binaries from the <a href="https://github.com/jgosmann/btdt/releases">GitHub Releases page</a>.
The archive contains a single executable binary <code>btdt</code>.
You might want to place it in your <code>$PATH</code> for easy access.</p>
<h2 id="docker-images"><a class="header" href="#docker-images">Docker images</a></h2>
<p>Docker images are available on <a href="https://hub.docker.com/r/jgosmann/btdt">Docker Hub</a>.
This allows to directly run <code>btdt</code> without installing it on your system:</p>
<pre><code class="language-sh">docker run jgosmann/btdt btdt --help
</code></pre>
<p>However, you will have to mount the directories with the cache and the files to cache into the container.
This can be done with the <a href="https://docs.docker.com/engine/storage/volumes/#syntax"><code>--mount</code> or <code>--volume</code> option</a>.</p>
<p>The images use Semantic Versioning tags. For example, <code>jgosmann/btdt:0.1</code>
refers to the latest <code>v0.1.x</code> image.</p>
<h2 id="build-from-source-using-rust"><a class="header" href="#build-from-source-using-rust">Build from source using Rust</a></h2>
<p>If you have Rust installed, you can build <code>btdt</code> from source using <code>cargo</code>:</p>
<pre><code class="language-sh">cargo install btdt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This guide will show you the general steps of using <code>btdt</code> to cache files, in particular,
installed dependencies of a package manager such as <code>npm</code>.
If you are looking to integrate <code>btdt</code> into a CI pipeline,
you might want to also check out the <a href="./ci-guides/overview.html">CI-specific integration guides</a>.</p>
<h2 id="determining-cache-keys"><a class="header" href="#determining-cache-keys">Determining cache keys</a></h2>
<p>Usually, you will have a file that completely specifies the dependencies and their versions of your project.
For example, in the JavaScript/NPM ecosystem, this is the <code>package-lock.json</code> file.
As long as it doesn't change, the installed dependencies will be the same and could be cached.
Thus, the primary cache key should be based on this file.</p>
<p>We can use the <code>btdt hash</code> command to generate a cache key from the file:</p>
<pre><code class="language-sh">CACHE_KEY=cache-key-$(btdt hash package-lock.json)
</code></pre>
<p>This calculates a cryptographic hash over the file contents and appends it to the string <code>cache-key-</code>.
The result could look something like <code>cache-key-f3dd7a501dd93486194e752557585a1996846b9a6df16e76f104e81192b0039f</code>.
If the <code>package-lock.json</code> file changes, the hash will change as well and the cache key will be different.</p>
<h2 id="trying-to-restore-the-cache"><a class="header" href="#trying-to-restore-the-cache">Trying to restore the cache</a></h2>
<p>Before we try to install the dependencies, e.g. with <code>npm ci</code>, we can try to restore the cache instead:</p>
<pre><code class="language-sh">btdt restore --cache path/to/cache --keys $CACHE_KEY node_modules
RESTORE_EXIT_CODE=$?
</code></pre>
<p><code>npm</code> will install the dependencies into <code>node_modules</code>, so we are using this as the target directory.
Furthermore, we will store the exit code because it comes in handy in the next step. It will be <code>0</code> if the cache was
restored successfully, and non-zero otherwise.</p>
<h2 id="installing-dependencies-and-storing-the-cache"><a class="header" href="#installing-dependencies-and-storing-the-cache">Installing dependencies and storing the cache</a></h2>
<p>If the cache could not be restored, we will install the dependencies with <code>npm ci</code>, and then store the installed
dependencies in the cache:</p>
<pre><code class="language-sh">if [ $RESTORE_EXIT_CODE -ne 0 ]; then
    npm ci  # Install dependencies
    btdt store --cache path/to/cache --keys $CACHE_KEY node_modules
fi
</code></pre>
<h2 id="using-multiple-cache-keys"><a class="header" href="#using-multiple-cache-keys">Using multiple cache keys</a></h2>
<p>You can specify multiple cache keys. This allows to have a fallback mechanism. The cache keys will be tried in order
during the restore operation and allow you to use a cache which might not contain the exact dependencies required, but
could still speed up the installation if most of them are contained.</p>
<p>With <code>npm</code> the usage of multiple cache keys could look like this:</p>
<pre><code class="language-sh">CACHE_KEY=cache-key-$(btdt hash package-lock.json)

btdt restore --cache path/to/cache --keys "$CACHE_KEY,fallback" node_modules
RESTORE_EXIT_CODE=$?

npm ci

if [ $RESTORE_EXIT_CODE -ne 0 ]; then
    btdt store --cache path/to/cache --keys $CACHE_KEY,fallback node_modules
fi
</code></pre>
<p>This will store the latest cached dependencies also under the key <code>fallback</code>. This cache entry will be used, if no more
specific cache enry is found.</p>
<h2 id="cleanup"><a class="header" href="#cleanup">Cleanup</a></h2>
<p>To prevent the cache from growing indefinitely, you might want to clean up old cache entries from time to time, for
example to only keep cache entries accessed within the last seven days and limit the cache size to at most 10 GiB:</p>
<pre><code class="language-sh">btdt clean --cache path/to/cache --max-age 7d --max-size 10GiB
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>While the <a href="ci-guides/../getting_started.html">Getting Started</a> guide provides a high-level overview of how to use <code>btdt</code>,
this section contains guides for specific CI systems:</p>
<ul>
<li><a href="ci-guides/./tekton.html">Tekton</a></li>
</ul>
<p>If you have experience with a CI system that is not covered here, please consider contributing a guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tekton"><a class="header" href="#tekton">Tekton</a></h1>
<p>This guide explains how to use <code>btdt</code> in a <a href="https://tekton.dev/">Tekton</a> pipeline.
It will use the Docker images, so that no changes to the images of your tasks are necessary.
Of course, you could also install <code>btdt</code> within the respective task images which might simplify the integration a bit.</p>
<h2 id="provide-a-persistent-volume-claim-as-workspace-to-the-pipeline-run"><a class="header" href="#provide-a-persistent-volume-claim-as-workspace-to-the-pipeline-run">Provide a Persistent Volume Claim as workspace to the pipeline run</a></h2>
<p>To use <code>btdt</code> in a Tekton pipeline, you need to provide a Persistent Volume Claim (PVC) for the cache.
This PVC should be provided as actual <code>persistentVolumeClaim</code> in the <code>PipelineRun</code>, not <code>volumeClaimTemplate</code>.
Otherwise, you will have a fresh volume on each pipeline run, making the cache useless.
An example <code>PipelineRun</code> could look like this:</p>
<pre><code class="language-yaml"># PipelineRun template, e.g. as part of your trigger
apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
  name: my-pipeline-run-$(uid)
spec:
  params:
  # ...
  pipelineRef:
    name: my-tekton-pipeline
  workspaces:
    - name: cache
      persistentVolumeClaim:
        claimName: my-tekton-cache
</code></pre>
<p>With the default Tekton settings (at time of writing), only a single PVC can be mounted into a task.
Thus, if you are already using a PVC for you task (likely to check out your source code repository),
you will have to also store the cache on this PVC.</p>
<p>Alternatively, you can disable the <a href="https://tekton.dev/docs/pipelines/affinityassistants/">affinity assistant</a> to be
able to mount multiple PVCs into a task. Run <code>kubectl edit configmap feature-flags</code> to edit the configuration.
In the following, we assume this second setup. If you are using a single PVC, you will have to adjust the paths
accordingly.</p>
<h2 id="provide-the-cache-workspace-to-the-task"><a class="header" href="#provide-the-cache-workspace-to-the-task">Provide the cache workspace to the task</a></h2>
<p>To be able to use the cache in a task, the cache workspace needs to be provided:</p>
<pre><code class="language-yaml"># pipeline.yaml
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: my-tekton-pipeline
spec:
  workspaces:
    - name: cache
  tasks:
    - name: run-tests
      taskRef:
        name: run-tests
        kind: Task
      workspaces:
        - name: git-sources
          workspace: git-sources
        - name: cache
          workspace: cache
</code></pre>
<h2 id="use-the-cache-in-a-task"><a class="header" href="#use-the-cache-in-a-task">Use the cache in a task</a></h2>
<p>You must declare the cache workspace in the task, so that it can be used by the individual steps:</p>
<pre><code class="language-yaml"># task_run-tests.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: run-tests
spec:
  steps:
  # ...
  workspaces:
    - name: git-sources
      description: Provides the workspace with the cloned repository.
    - name: cache
      description: Provides the btdt cache.
</code></pre>
<h3 id="restore-the-cache"><a class="header" href="#restore-the-cache">Restore the cache</a></h3>
<p>Now you can add a step to restore the cache at the beginning of the task.
Here, we try to restore a <code>node_modules</code> directory:</p>
<pre><code class="language-yaml"># task_run-tests.yaml
spec:
  # ...
  steps:
    - name: restore-cache
      image: jgosmann/btdt:0.1
      workingDir: $(workspaces.cache.path)
      onError: continue
      script: |
        #!/bin/sh
        CACHE_KEY=node-modules-$(btdt hash package-lock.json)
        echo "Cache key: $CACHE_KEY"
        btdt restore --cache $(workspaces.cache.path) --keys $CACHE_KEY node_modules
</code></pre>
<h3 id="install-dependencies-only-on-cache-miss"><a class="header" href="#install-dependencies-only-on-cache-miss">Install dependencies only on cache miss</a></h3>
<p>Depending on what you are caching, you might want to run some commands only a cache miss to generate the files that
would be cached.
For example, to install NPM dependencies only if the cache could not be restored:</p>
<pre><code class="language-yaml"># task_run-tests.yaml
spec:
  # ...
  steps:
    # try restore
    - name: run-tests
      image: node
      workingDir: $(workspaces.git-sources.path)
      script: |
        #!/bin/sh
        if [ $(cat $(steps.step-restore-cache.exitCode.path)) -eq 0 ]; then
          echo "Cache restore succeeded, skipping npm ci"
        else
          npm ci
        fi
        # run tests, build, etc.
</code></pre>
<p>Note, if you are using <a href="ci-guides/../getting_started.html#using-multiple-cache-keys">fallback keys</a>, you would always want to run
<code>npm ci</code> to ensure that the dependencies are installed correctly.</p>
<h3 id="store-the-cache"><a class="header" href="#store-the-cache">Store the cache</a></h3>
<p>For the cache to provide a benefit, we need to fill it if a cache miss occurred. This requires an additional step
after the files to cache have been generated (e.g. by running <code>npm ci</code>):</p>
<pre><code class="language-yaml"># task_run-tests.yaml
spec:
  # ...
  steps:
    # try restore
    # install dependencies/generate files to cache
    - name: store-cache
      image: jgosmann/btdt:0.1
      workingDir: $(workspaces.git-sources.path)
      script: |
        #!/bin/sh
        if [ $(cat $(steps.step-restore-cache.exitCode.path)) -eq 0 ]; then
            echo "Cache restore succeeded, skipping cache store"
            exit 0
        fi
        CACHE_KEY=node-modules-$(btdt hash package-lock.json)
        echo "Cache key: $CACHE_KEY"
        btdt store --cache $(workspaces.cache.path) --keys $CACHE_KEY node_modules
</code></pre>
<h3 id="example-of-complete-task"><a class="header" href="#example-of-complete-task">Example of complete task</a></h3>
<p>When putting all of this together, your task definition will look something like this:</p>
<pre><code class="language-yaml"># task_run-tests.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: run-tests
spec:
  steps:
    - name: restore-cache
      image: jgosmann/btdt:0.1
      workingDir: $(workspaces.git-sources.path)
      onError: continue
      script: |
        #!/bin/sh
        CACHE_KEY=node-modules-$(btdt hash package-lock.json)
        echo "Cache key: $CACHE_KEY"
        btdt restore --cache $(workspaces.cache.path) --keys $CACHE_KEY node_modules
    - name: run-tests
      image: node
      workingDir: $(workspaces.git-sources.path)
      script: |
        #!/bin/sh
        if [ $(cat $(steps.step-restore-cache.exitCode.path)) -eq 0 ]; then
          echo "Cache restore succeeded, skipping npm ci"
        else
          npm ci
        fi
        # run tests etc.
    - name: store-cache
      image: jgosmann/btdt
      workingDir: $(workspaces.git-sources.path)
      script: |
        #!/bin/sh
        if [ $(cat $(steps.step-restore-cache.exitCode.path)) -eq 0 ]; then
            echo "Cache restore succeeded, skipping cache store"
            exit 0
        fi
        CACHE_KEY=node-modules-$(btdt hash package-lock.json)
        echo "Cache key: $CACHE_KEY"
        btdt store --cache $(workspaces.cache.path) --keys $CACHE_KEY node_modules

  workspaces:
    - name: git-sources
      description: Provides the workspace with the cloned repository.
    - name: cache
      description: Provides btdt cache.
</code></pre>
<h2 id="cleanup-1"><a class="header" href="#cleanup-1">Cleanup</a></h2>
<p>To prevent the cache from growing indefinitely, you should configure a regular cleanup:</p>
<h3 id="clean-task"><a class="header" href="#clean-task">Clean task</a></h3>
<pre><code class="language-yaml"># task_cache-clean.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: cache-clean
spec:
  steps:
    - name: cache-clean
      image: jgosmann/btdt:0.1
      script: |
        #!/bin/sh
        btdt clean --cache $(workspaces.cache.path) --max-age 7d --max-size 10GiB
  workspaces:
    - name: cache
      description: Provides the btdt cache.
</code></pre>
<h3 id="clean-pipeline"><a class="header" href="#clean-pipeline">Clean pipeline</a></h3>
<pre><code class="language-yaml"># pipeline_cache-clean.yaml
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: cache-clean-pipeline
spec:
  workspaces:
    - name: cache
  params:
    - name: runid
      type: string
  tasks:
    - name: cache-clean
      taskRef:
        name: cache-clean
        kind: Task
      workspaces:
        - name: cache
          workspace: cache
</code></pre>
<h3 id="cron-trigger"><a class="header" href="#cron-trigger">Cron trigger</a></h3>
<pre><code class="language-yaml"># trigger_cache-clean.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: cache-clean-schedule
spec:
  schedule: '@hourly'
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - name: cache-clean-trigger
              image: curlimages/curl
              command: [ '/bin/sh', '-c' ]
              args: [ "curl --header \"Content-Type: application/json\" --data '{}' el-cache-clean-listener.default.svc.cluster.local:8080" ]
          restartPolicy: Never

---
apiVersion: triggers.tekton.dev/v1alpha1
kind: EventListener
metadata:
  name: cache-clean-listener
spec:
  triggers:
    - name: cache-clean-trigger
      interceptors: [ ]
      template:
        spec:
          resourcetemplates:
            - apiVersion: tekton.dev/v1beta1
              kind: PipelineRun
              metadata:
                name: cache-clean-$(uid)
              spec:
                pipelineRef:
                  name: cache-clean-pipeline
                params:
                  - name: runid
                    value: $(uid)
                workspaces:
                  - name: cache
                    persistentVolumeClaim:
                      claimName: my-tekton-cache
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
